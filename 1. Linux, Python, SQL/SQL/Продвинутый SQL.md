<h2>Продвинутый SQL</h2>
<h3>1. Хранимые процедуры, функции и триггеры</h3>
<h4>Хранимые процедуры</h4>

Хранимая процедура (Stored Procedure) — это заранее подготовленный и сохраненный в базе данных набор SQL-инструкций, который выполняется как единое целое. Её можно рассматривать как аналог функции или метода в процедурных языках программирования.

Для чего нужны:
- Инкапсуляция логики: Сложная бизнес-логика прячется внутри процедуры. Клиентскому приложению нужно только вызвать её, не зная деталей реализации.
- Производительность: Снижается сетевой трафик (передается только вызов, а не множество отдельных запросов). Сервер кэширует план выполнения процедуры.
- Безопасность: Можно дать пользователю права на выполнение процедуры, даже если у него нет прямых прав на таблицы, с которыми она работает.
- Целостность данных: Группа операций может быть объединена в транзакцию внутри процедуры, что гарантирует согласованность данных.

Создание и вызов процедуры:
```sql
-- Процедура, которая добавляет нового клиента
CREATE PROCEDURE AddNewCustomer(
    IN p_CustomerName VARCHAR(100),
    IN p_ContactEmail VARCHAR(100),
    OUT p_NewCustomerID INT
)
BEGIN
    -- Вставляем новую запись
    INSERT INTO Customers (CustomerName, ContactEmail)
    VALUES (p_CustomerName, p_ContactEmail);
    -- Получаем ID нового клиента и возвращаем его через OUT-параметр
    SET p_NewCustomerID = LAST_INSERT_ID();
END;

-- Вызов процедуры
CALL AddNewCustomer('ООО "Вектор"', 'info@vector.ru', @NewID);

-- Использование возвращенного значения
SELECT @NewID as NewCustomerID;
```

Параметры процедур бывают трех типов:
- IN параметры: передаются в процедуру, но их изменение внутри процедуры не видно снаружи.
- OUT параметры: не передаются в процедуру (хотя синтаксис вызова может требовать указания переменной), но их значение устанавливается внутри процедуры и становится доступным вызывающей стороне.
- INOUT параметры: комбинация — передаются в процедуру и могут быть изменены.

<h4>Хранимые функции</h4>

Хранимая функция (Stored Function, или User-Defined Function - UDF) — это подпрограмма, которая возвращает единственное значение (скаляр) или таблицу. Ключевое отличие — функция предназначена для вычисления значения и использования его внутри SQL-выражений.

Для чего нужны:
- Модульность и повторное использование: Сложные расчеты или преобразования данных выносятся в функцию.
- Использование в запросах: Функцию можно использовать в `SELECT`, `WHERE`, `JOIN` и других частях SQL-запроса, как встроенные функции (`UPPER()`, `SUM()`).

Создание и вызов функции:
```sql
-- Функция, которая вычисляет общую сумму заказа
CREATE FUNCTION GetOrderTotalAmount(p_OrderID INT)
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE total DECIMAL(10,2);

    SELECT SUM(UnitPrice * Quantity)
    INTO total
    FROM OrderDetails
    WHERE OrderID = p_OrderID;

    RETURN total;
END;

-- Использование в SELECT
SELECT
    OrderID,
    GetOrderTotalAmount(OrderID) as TotalAmount
FROM Orders
WHERE OrderID = 12345;

-- Использование в WHERE
SELECT OrderID
FROM Orders
WHERE GetOrderTotalAmount(OrderID) > 1000;
```

Детали определения:
- `RETURNS` — указывает тип данных возвращаемого значения.

- `DETERMINISTIC` / `NOT DETERMINISTIC`: Детерминированная функция всегда возвращает один и тот же результат для одних и тех же входных параметров (например, `UPPER()`). Недетерминированная — может возвращать разный результат (например, функция, использующая `CURRENT_TIMESTAMP`).

- `READS SQL DATA` — указывает, что функция только читает данные. Бывают также `MODIFIES SQL DATA` и др.

Сравнение с процедурой:
- Не может управлять транзакциями
- Может вызываться как часть SQL выражения (В `SELECT`, `WHERE`, `HAVING` и др.)
- Всегда возвращает одно значение, процедура может возвращать ничего или несколько значений
- В большинстве СУБД не может выполнять DML операции

<h3>2. Транзакции</h3>

Транзакция в SQL — это логическая единица работы с базой данных, которая состоит из последовательности операций, выполняемых как единое целое.

Принципы ACID:
- Атомарность (Atomicity): Транзакция выполняется целиком или не выполняется вовсе. При ошибке все изменения откатываются.
- Согласованность (Consistency): Транзакция переводит базу данных из одного целостного состояния в другое (например, не нарушаются ограничения целостности).
- Изоляция (Isolation): Параллельные транзакции не влияют друг на друга. Уровни изоляции (например, `READ COMMITTED`, `SERIALIZABLE`) регулируют степень видимости изменений между транзакциями.
- Долговечность (Durability): После завершения транзакции (коммита) изменения сохраняются даже при сбое системы.

<h4>Уровни изоляции транзакций</h4>

Уровни изоляции определены в стандарте SQL (ANSI/ISO) и включают четыре уровня. Они предназначены для управления видимостью изменений, сделанных в одной транзакции, для других параллельных транзакций. Каждый уровень изоляции предотвращает определенные аномалии, но за более высокий уровень изоляции приходится платить производительностью (из-за блокировок или механизмов управления версиями).

Некоторые аномалии которые могут возникнуть при разных уровнях изоляции:
- Потерянное обновление (Lost Update): Две транзакции одновременно обновляют одни и те же данные, и одно из обновлений теряется (перезаписывается другим).
- Грязное чтение (Dirty Read): Транзакция читает незафиксированные изменения другой транзакции. Если та транзакция откатывается, то первая транзакция прочитала данные, которых никогда не было.
- Неповторяющееся чтение (Non-repeatable Read): Транзакция дважды читает одни и те же данные, но получает разные значения, потому что другая транзакция изменила и зафиксировала эти данные между чтениями.
- Фантомное чтение (Phantom Read): Транзакция повторно выполняет запрос, возвращающий набор строк по некоторому условию, и обнаруживает, что набор строк изменился из-за того, что другая транзакция добавила или удалила строки, удовлетворяющие условию, и зафиксировала изменения.

Уровни изоляции (от низкого к высокому):
- Read Uncommitted (Чтение незафиксированных данных) - транзакции видят незафиксированные изменения других транзакций. Не предотвращает аномалий.
- Read Committed (Чтение зафиксированных данных) - транзакция видит только зафиксированные изменения других транзакций. Предотвращает грязное чтение.
- Repeatable Read (Повторяемое чтение) - гарантирует, что если транзакция прочитала данные, то при повторном чтении она увидит те же данные (даже если другие транзакции изменили и зафиксировали эти данные). Однако новые строки (фантомы) могут появляться. Предотвращает грязное и неповторяющееся чтение.
- Serializable (Сериализуемый) - гарантирует, что результат параллельного выполнения транзакций такой же, как если бы они выполнялись последовательно (одна за другой). Достигается за счет строгих блокировок или многовариантного управления версиями (MVCC) с проверкой на конфликты. Предотвращает все аномалии.

Установка уровня изоляции:
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

<h4>Работа с транзакциями</h4>

Команды TCL:
- `START TRANSACTION` - начало транзакции
- `COMMIT` - завершение транзакции с сохранением изменений
- `ROLLBACK` - завершение транзакции с отменой изменений
- `SAVEPOINT `- точка сохранения в транзакции

Пример использования:
```sql
BEGIN TRANSACTION;
INSERT INTO table1 VALUES (1);
SAVEPOINT savepoint1;
INSERT INTO table1 VALUES (2);
ROLLBACK TO savepoint1; -- Вторая вставка откатывается, первая остается.
COMMIT;                 -- Сохраняется только первая вставка.
```

<h4>Механизмы обеспечения ACID в распределенных системах</h4>

В распределенных системах обеспечение ACID становится сложнее, потому что данные находятся на нескольких узлах, и нужно координировать транзакции между ними:
- Атомарность - протокол двухфазной фиксации (2PC): узел-координатор отправляет команду подготовки к транзакции другим узлам, транзакция выполняется всеми узлами до точки фиксации, изменения записываются во временный журнал. Затем узлы отправляют координатору о готовности завершения транзакции, если хотя бы один из узлов не готов - транзакция откатывается.
- Согласованность - в зависимости от системы используются разные модели согласованности. Для обеспечения строгой согласованности используются консенсус-алгоритмы (Paxos, Raft). Если доступ к данных важнее используется согласованность в конечном счете - данные асинхронно копируются на зависимые узлы.
- Изоляция - использование снимков состояния: используется глобальный временной штамп для определения согласованного снимка данных across узлов.
- Долговечность - обеспечивается засчет репликации данных на другие узлы.

<h3>3. Индексы</h3>

Индекс в SQL — это специальная структура данных, которая ускоряет операции извлечения данных из таблицы за счет уменьшения количества строк, которые необходимо просматривать. Лучше использовать индексы для столбцов, часто использующихся в `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`, а также обладающих большим количеством уникальных значений. Не рекомендуется использовать индексы на часто обновляемых полях.

Преимущества:
- Ускорение поиска: Позволяют быстро находить данные без полного сканирования таблицы.
- Оптимизация сортировки: Ускоряют `ORDER BY` и `GROUP BY`.
- Поддержка уникальности: Гарантируют отсутствие дубликатов (уникальные индексы).
- Эффективные `JOIN`: Ускоряют соединения таблиц по ключам.

Ограничения:
- Занимают дополнительное место на диске.
- Замедляют операции `INSERT`, `UPDATE`, `DELETE` (индексы нужно перестраивать).

Типы индексов:
- B-tree - Стандартный индекс для диапазонных запросов и сортировки. Подходит для большинства случаев (числа, строки, даты).
- Hash - Использует хеш-функции, работает только для точного поиска (=). Быстрее B-tree для =, но не поддерживает диапазоны (>, <).
- Bitmap - Хранит битовые карты для каждого значения. Эффективен для столбцов с малым числом уникальных значений (например, «пол»).
- Full-Text - Оптимизирован для поиска по тексту. Используется в WHERE text_column LIKE '%keyword%'.
- Составной - Создается на несколько столбцов. Эффективен, если в запросах используются несколько полей.
- Покрывающий - Содержит все данные запроса, избегая обращения к таблице. Ускоряет SELECT, если индекс включает все нужные столбцы.

<h4>Создание индексов различных типов</h4>

```sql
CREATE INDEX index_name ON table_name(column_name)               -- B-tree индекс
CREATE UNIQUE INDEX index_name ON table_name(column_name)        -- Уникальный индекс
CREATE INDEX index_name ON table_name(col1, col2, col3)          -- Составной индекс
CREATE INDEX index_name ON table_name USING HASH(column_name)    -- Hash индекс
CREATE FULLTEXT INDEX index_name ON table_name(column_name)      -- Полнотекстовый индекс
```

<h3>4. Партицирование таблиц</h3>

Партицирование — это метод разделения большой таблицы на меньшие, более управляемые части (партиции) на основе определённых правил. Каждая партиция хранится как отдельный физический объект, но логически представляет собой единую таблицу.

Преимущества:
- Ускорение запросов, которые затрагивают только определенные партиции
- Упрощение операций с данными (архивация, удаление)
- Возможность работать с отдельными партициями независимо
- Размещение "горячих" и "холодных" данных на разных носителях

<h4>Партицирование по диапазону значений</h4>

Создание таблицы с партициями:
```sql
CREATE TABLE sales (
    sale_id INT AUTO_INCREMENT,
    sale_date DATE NOT NULL,
    customer_id INT,
    amount DECIMAL(10,2),
    PRIMARY KEY (sale_id, sale_date)
) PARTITION BY RANGE COLUMNS(sale_date) (
    PARTITION p_2023_01 VALUES LESS THAN ('2023-02-01'),
    PARTITION p_2023_02 VALUES LESS THAN ('2023-03-01'),
    PARTITION p_2023_03 VALUES LESS THAN ('2023-04-01'),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

Добавление партиций:
```sql
ALTER TABLE sales REORGANIZE PARTITION p_future INTO (
    PARTITION p2023_04 VALUES LESS THAN ('2023-05-01'),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

Удаление партиций:
```sql
-- Удаление партиции и данных
ALTER TABLE sales DROP PARTITION p2020;

-- Удаление данных из партиции без удаления самой партиции
ALTER TABLE sales TRUNCATE PARTITION p2021;
```

<h3>5. Оптимизация запросов</h3>
<h4>Запросы с IN, NOT IN</h4>

Система проверяет каждое значение из списка, что может быть медленно, также, если в подзапросе с `NOT IN` есть `NULL`, то результатом будет `FALSE`. Для подобных подзапросов СУБД может использовать медленный алгоритм. Для решения данной проблемы есть несколько решений:

Использование `EXISTS`:

```sql
-- Было
SELECT *
  FROM Orders
 WHERE CustomerID IN
       (SELECT CustomerID
          FROM Customers
         WHERE Region = 'EU');

-- Стало
SELECT *
  FROM Orders AS o
 WHERE EXISTS
       (SELECT 0
          FROM Customers AS c
         WHERE c.CustomerID = o.CustomerID
           AND c.Region = 'EU');
```
Использование `LEFT JOIN` с условием (для `NOT IN`):

```sql
-- Было
SELECT * FROM Orders
 WHERE CustomerID NOT IN
       (SELECT CustomerID
         FROM Customers);

-- Стало
SELECT o.* 
  FROM Orders AS o
       LEFT JOIN Customers AS c
       ON o.CustomerID = c.CustomerID
 WHERE c.CustomerID IS NULL;
```

<h4>Запросы с JOIN</h4>

Для оптимизации запросов с `JOIN` можно применять следующее:
- Создавать индексы на столбцах, участвующих в `JOIN` (внешние ключи).
- Упорядочивать таблицы в `JOIN` начиная с самой маленькой или самой селективной таблицы.
- Использовать предварительную фильтрацию

Пример (изменение порядка в `JOIN` и предварительная фильтрация):
```sql
-- Было
SELECT *
  FROM Orders AS o
       JOIN Customers c ON o.CustomerID = c.CustomerID
 WHERE o.OrderDate > '2023-01-01';

-- Стало
SELECT *
  FROM Customers AS c
       JOIN
       (SELECT *
          FROM Orders
         WHERE OrderDate > '2023-01-01') AS o
       ON o.CustomerID = c.CustomerID;
```

<h4>Запросы с временными таблицами</h4>

Временные таблицы используются когда нужно разбить сложный запрос на несколько шагов и когда один набор данных используется многократно. Для оптимизации запросов с ними рекомендуется применять следующее:
- Создавать индексы на временных таблицах.
- Использовать `SELECT ... INTO` или `CREATE TABLE ... AS` вместо `INSERT ... SELECT`, если это позволяет СУБД.
- Анализировать данные во временной таблице с помощью команды `ANALYZE`.

Пример:
```sql
-- Шаг 1: Создаем временную таблицу с отфильтрованными заказами
SELECT OrderID, CustomerID, Amount
  INTO #FilteredOrders
  FROM Orders
 WHERE OrderDate > '2023-01-01';

-- Создаем индекс для быстрого JOIN
CREATE INDEX idx_temp ON #FilteredOrders (CustomerID);

-- Шаг 2: Используем ее в соединении
SELECT c.CustomerName, SUM(fo.Amount)
  FROM Customers AS c
       JOIN #FilteredOrders AS fo ON c.CustomerID = fo.CustomerID
 GROUP BY c.CustomerName;
```

<h3>6. Представления</h3>
<h4>Обычные представления</h4>

Представление (View) — это виртуальная таблица, результат запроса, который сохранен в базе данных под определенным именем. Например, для БД с таблицами `Employees`, `Departments` и `Salaries` можно создать представление `Active_Employees_Info`, которое будет показывать только имя, должность и отдел для всех активных сотрудников, скрывая их зарплату и другую конфиденциальную информацию. Представления могут взаимодейтвовать с другими таблицами и представлениями точно также, как и обычные таблицы.

Особенности:
- Не хранит данные: Представление само по себе не содержит данных. Оно хранит только определение (SQL-запрос). При каждом обращении к представлению выполняется этот запрос, и возвращаются актуальные данные из базовых таблиц.
- Права доступа: Работа с представлением регулируется правами доступа. Пользователь может иметь доступ к представлению, но не к исходным таблицам.

Преимущества использования представлений:
- Безопасность - можно скрыть конфиденциальные столбцы или строки. Например, предоставить доступ к представлению с именами сотрудников, но без их зарплат.
- Упрощение сложных запросов - если есть сложный запрос с множеством JOIN и подзапросов, можно инкапсулировать его в представление. После этого пользователи могут делать простой SELECT * FROM complex_view, не вдаваясь в детали.
- Согласованность логики - бизнес-логика записывается в представление один раз и используется повсеместно. Это предотвращает дублирование кода и ошибки.
- Абстракция данных - если структура базовых таблиц изменяется, можно изменить представление так, чтобы оно продолжало возвращать те же данные, и старые запросы, использующие это представление, не сломаются.

Создание представления:
```sql
CREATE VIEW German_Customers AS
SELECT CustomerName, ContactName, Email
FROM Customers
WHERE Country = 'Germany';
```

Изменение представления:
```sql
ALTER VIEW German_Customers AS
SELECT CustomerName, ContactName, Email, City, Phone
FROM Customers
WHERE Country = 'Germany';
```

Удаление представления:
```sql
DROP VIEW German_Customers;
```

Изменяемые представления - это обычные (не материализованные) представления, через которые можно выполнять операции модификации данных (`INSERT`, `UPDATE`, `DELETE`), и эти изменения применяются к базовым таблицам. Для того чтобы представление было изменяемым оно должно быть основано на одной базовой таблице и не содержать:
- Группировку и агрегатные функции
- Оконные функции
- Операторы работы с множествами
- Подзапросы в `SELECT`

<h4>Материализованные представления</h4>

Материализованное представление — это объект базы данных, который хранит результат запроса в виде физических данных, подобно таблице. В отличие от обычного представления, которое каждый раз выполняет запрос при обращении, материализованное представление хранит данные на диске и обновляется по расписанию или вручную.

Отличия от обычных представлений:
- Хранение данных - обычное представление не хранит данные.
- Актуальность данных - материализованное представление может содержать устаревшие данные до следующего обновления.
- Производительность - материализованные представления могут быть быстрее для сложных запросов, так как данные уже предварительно вычислены.
- Обновление - материализованные представления нужно обновлять.

Преимущества:
- Высокая производительность для сложных запросов.
- Снижение нагрузки на источник данных.
- Возможность индексирования материализованных данных.

Ограничения:
- Данные могут быть неактуальными.
- Требуется место для хранения данных.
- Процесс обновления может быть ресурсоемким.

Материализованные представления создаются подобно обычным, но добавляется ключевое слово `MATERIALIZED`:
```sql
CREATE MATERIALIZED VIEW German_Customers AS
SELECT CustomerName, ContactName, Email
FROM Customers
WHERE Country = 'Germany';
```

Для обновления данных материализованного представления используется команда:
```sql
REFRESH MATERIALIZED VIEW German_Customers;
```

Поскольку материализованные представления хранят данные, мы можем создавать индексы на них для ускорения запросов. Это особенно полезно, если запросы к материализованному представлению сами по себе сложны. Индексы на материализованных представлениях ускоряют выполнение запросов к ним, но замедляют процесс обновления (как полного, так и инкрементального), потому что при обновлении представления индексы приходится также обновлять.
```sql
CREATE INDEX idx_German_Customers_Email ON German_Customers (Email);
```
