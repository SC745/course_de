<h2>Продвинутый SQL</h2>
<h3>1. Хранимые процедуры, функции и триггеры</h3>
<h4>Хранимые процедуры</h4>

Хранимая процедура (Stored Procedure) — это заранее подготовленный и сохраненный в базе данных набор SQL-инструкций, который выполняется как единое целое. Её можно рассматривать как аналог функции или метода в процедурных языках программирования.

Для чего нужны:
- Инкапсуляция логики: Сложная бизнес-логика прячется внутри процедуры. Клиентскому приложению нужно только вызвать её, не зная деталей реализации.
- Производительность: Снижается сетевой трафик (передается только вызов, а не множество отдельных запросов). Сервер кэширует план выполнения процедуры.
- Безопасность: Можно дать пользователю права на выполнение процедуры, даже если у него нет прямых прав на таблицы, с которыми она работает.
- Целостность данных: Группа операций может быть объединена в транзакцию внутри процедуры, что гарантирует согласованность данных.

Создание и вызов процедуры:
```sql
-- Процедура, которая добавляет нового клиента
CREATE PROCEDURE AddNewCustomer(
    IN p_CustomerName VARCHAR(100),
    IN p_ContactEmail VARCHAR(100),
    OUT p_NewCustomerID INT
)
BEGIN
    -- Вставляем новую запись
    INSERT INTO Customers (CustomerName, ContactEmail)
    VALUES (p_CustomerName, p_ContactEmail);
    -- Получаем ID нового клиента и возвращаем его через OUT-параметр
    SET p_NewCustomerID = LAST_INSERT_ID();
END;

-- Вызов процедуры
CALL AddNewCustomer('ООО "Вектор"', 'info@vector.ru', @NewID);

-- Использование возвращенного значения
SELECT @NewID as NewCustomerID;
```

Параметры процедур бывают трех типов:
- IN параметры: передаются в процедуру, но их изменение внутри процедуры не видно снаружи.
- OUT параметры: не передаются в процедуру (хотя синтаксис вызова может требовать указания переменной), но их значение устанавливается внутри процедуры и становится доступным вызывающей стороне.
- INOUT параметры: комбинация — передаются в процедуру и могут быть изменены.

Работа с транзакцией с помощью процедуры - жто помогает обеспечить атомарность операций внутри процедуры:
```sql
DELIMITER //

CREATE PROCEDURE TransactionExample()
BEGIN
    -- Объявляем обработчик для автоматического отката при ошибках
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    START TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    COMMIT;
END //

DELIMITER ;
```

Также в хранимых процедурах можно использовать курсоры - объекты базы данных, которые позволяЮт перебирать строки результирующего набора построчно и выполнять операции над каждой строкой. В основном применяются для интеграции с внешними системами и для выполнения сложных операций. Пример:
```sql
DELIMITER //

CREATE PROCEDURE ProcessWithCursor()
BEGIN
    DECLARE done BOOLEAN DEFAULT FALSE;
    DECLARE var_id INT;
    DECLARE var_name VARCHAR(100);
    DECLARE var_salary DECIMAL(10,2);
    DECLARE cur CURSOR FOR SELECT id, name, salary FROM employees WHERE department = 'IT';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO var_id, var_name, var_salary;
        IF done THEN
            LEAVE read_loop;
        END IF;
        CALL ProcessEmployee(var_id, var_name, var_salary);
    END LOOP;
    CLOSE cur;
END //

DELIMITER ;
```

<h4>Хранимые функции</h4>

Хранимая функция (Stored Function, или User-Defined Function - UDF) — это подпрограмма, которая возвращает единственное значение (скаляр) или таблицу. Ключевое отличие — функция предназначена для вычисления значения и использования его внутри SQL-выражений.

Для чего нужны:
- Модульность и повторное использование: Сложные расчеты или преобразования данных выносятся в функцию.
- Использование в запросах: Функцию можно использовать в `SELECT`, `WHERE`, `JOIN` и других частях SQL-запроса, как встроенные функции (`UPPER()`, `SUM()`).

Создание и вызов функции:
```sql
-- Функция, которая вычисляет общую сумму заказа
CREATE FUNCTION GetOrderTotalAmount(p_OrderID INT)
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE total DECIMAL(10,2);

    SELECT SUM(UnitPrice * Quantity)
    INTO total
    FROM OrderDetails
    WHERE OrderID = p_OrderID;

    RETURN total;
END;

-- Использование в SELECT
SELECT
    OrderID,
    GetOrderTotalAmount(OrderID) as TotalAmount
FROM Orders
WHERE OrderID = 12345;

-- Использование в WHERE
SELECT OrderID
FROM Orders
WHERE GetOrderTotalAmount(OrderID) > 1000;
```

Детали определения:
- `RETURNS` — указывает тип данных возвращаемого значения.
- `DETERMINISTIC` / `NOT DETERMINISTIC`: Детерминированная функция всегда возвращает один и тот же результат для одних и тех же входных параметров (например, `UPPER()`). Недетерминированная — может возвращать разный результат (например, функция, использующая `CURRENT_TIMESTAMP`).
- `READS SQL DATA` — указывает, что функция только читает данные. Бывают также `MODIFIES SQL DATA` и др.

Сравнение с процедурой:
- Не может управлять транзакциями
- Может вызываться как часть SQL выражения (В `SELECT`, `WHERE`, `HAVING` и др.)
- Всегда возвращает одно значение, процедура может возвращать ничего или несколько значений
- В большинстве СУБД не может выполнять DML операции

Реализация рекурсии (с помощью рекурсивного CTE):
```sql
DELIMITER //

CREATE FUNCTION CalculateFactorial(n INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE result INT;

    WITH RECURSIVE factorial_cte (n, fact) AS (
        SELECT 1, 1
        UNION ALL
        SELECT n + 1, fact * (n + 1)
          FROM factorial_cte
         WHERE n < CalculateFactorial.n  -- Обращение к параметру функции
    )
    SELECT fact INTO result
      FROM factorial_cte
     ORDER BY n DESC
    LIMIT 1;

    RETURN result;
END //

DELIMITER ;
```

<h4>Триггеры</h4>

Триггеры — это специальные хранимые процедуры, которые автоматически выполняются при возникновении определенных событий в таблице базы данных. Эти события могут быть связаны с операциями DML (Data Manipulation Language), такими как `INSERT`, `UPDATE`, `DELETE`, или DDL (Data Definition Language), например, создание или изменение таблиц. Они могут срабатывать до (`BEFORE`) или после (`AFTER`) события, а в некоторых СУБД (например, PostgreSQL) — вместо (`INSTEAD OF`) события.
Триггеры часто используются для:
- Проверки целостности данных.
- Автоматического обновления связанных данных.
- Логирования изменений.
- Реализации сложных бизнес-правил.

Синтаксис создания триггера:
```sql
CREATE TRIGGER trigger_name
[BEFORE | AFTER | INSTEAD OF] [INSERT | UPDATE | DELETE]
ON table_name
[FOR EACH ROW | FOR EACH STATEMENT]
[WHEN (condition)]
BEGIN
    -- Логика триггера
END;
```
- BEFORE/AFTER/INSTEAD OF: Определяют момент срабатывания.
- FOR EACH ROW: Триггер выполняется для каждой изменяемой строки.
- FOR EACH STATEMENT: Триггер выполняется один раз для всего оператора.
- WHEN: Условие, при котором триггер активируется.

Пример (автоматическое обновление поля при обновлении данных):
```sql
CREATE TRIGGER update_product_timestamp
BEFORE UPDATE ON products
FOR EACH ROW
BEGIN
    NEW.last_updated = CURRENT_TIMESTAMP;
END;
```
- NEW: ссылается на новую строку для операций INSERT и UPDATE. В триггерах DELETE не существует NEW.
- OLD: ссылается на старую строку для операций UPDATE и DELETE. В триггерах INSERT не существует OLD.

Триггеры могут вызвать бесконечную рекурсию, если они вызывают сами себя по цепочке. Чтобы этого избежать можно применить следующее:
- Временное отключение триггера (если СУБД позволяет):
```sql
ALTER TABLE table_name DISABLE TRIGGER trigger_name;
# Выполнение операции
ALTER TABLE table_name ENABLE TRIGGER trigger_name;
```
- Использование флагов (например, через временную таблицу или переменные):
```sql
CREATE TRIGGER prevent_recursion
BEFORE UPDATE ON accounts
FOR EACH ROW
BEGIN
    -- Проверка флага рекурсии
    IF @is_trigger_active IS NULL THEN
        SET @is_trigger_active = 1;
        -- Логика триггера
        UPDATE accounts SET balance = NEW.balance * 1.1 WHERE id = NEW.id;
        SET @is_trigger_active = NULL;
    END IF;
END;
```
- Ограничение рекурсии на уровне СУБД. Например, в SQL Server:
```sql
ALTER DATABASE database_name SET RECURSIVE_TRIGGERS OFF;
```
- Условия в триггере. Например, обновлять поле только если его значение действительно изменилось:
```sql
CREATE TRIGGER update_only_if_changed
BEFORE UPDATE ON products
FOR EACH ROW
BEGIN
    IF OLD.price <> NEW.price THEN
        NEW.last_updated = CURRENT_TIMESTAMP;
    END IF;
END;
```

<h3>2. Транзакции</h3>

Транзакция в SQL — это логическая единица работы с базой данных, которая состоит из последовательности операций, выполняемых как единое целое.

Принципы ACID:
- Атомарность (Atomicity): Транзакция выполняется целиком или не выполняется вовсе. При ошибке все изменения откатываются.
- Согласованность (Consistency): Транзакция переводит базу данных из одного целостного состояния в другое (например, не нарушаются ограничения целостности).
- Изоляция (Isolation): Параллельные транзакции не влияют друг на друга. Уровни изоляции (например, `READ COMMITTED`, `SERIALIZABLE`) регулируют степень видимости изменений между транзакциями.
- Долговечность (Durability): После завершения транзакции (коммита) изменения сохраняются даже при сбое системы.

<h4>Уровни изоляции транзакций</h4>

Уровни изоляции определены в стандарте SQL (ANSI/ISO) и включают четыре уровня. Они предназначены для управления видимостью изменений, сделанных в одной транзакции, для других параллельных транзакций. Каждый уровень изоляции предотвращает определенные аномалии, но за более высокий уровень изоляции приходится платить производительностью (из-за блокировок или механизмов управления версиями).

Некоторые аномалии которые могут возникнуть при разных уровнях изоляции:
- Потерянное обновление (Lost Update): Две транзакции одновременно обновляют одни и те же данные, и одно из обновлений теряется (перезаписывается другим).
- Грязное чтение (Dirty Read): Транзакция читает незафиксированные изменения другой транзакции. Если та транзакция откатывается, то первая транзакция прочитала данные, которых никогда не было.
- Неповторяющееся чтение (Non-repeatable Read): Транзакция дважды читает одни и те же данные, но получает разные значения, потому что другая транзакция изменила и зафиксировала эти данные между чтениями.
- Фантомное чтение (Phantom Read): Транзакция повторно выполняет запрос, возвращающий набор строк по некоторому условию, и обнаруживает, что набор строк изменился из-за того, что другая транзакция добавила или удалила строки, удовлетворяющие условию, и зафиксировала изменения.

Уровни изоляции (от низкого к высокому):
- Read Uncommitted (Чтение незафиксированных данных) - транзакции видят незафиксированные изменения других транзакций. Не предотвращает аномалий.
- Read Committed (Чтение зафиксированных данных) - транзакция видит только зафиксированные изменения других транзакций. Предотвращает грязное чтение.
- Repeatable Read (Повторяемое чтение) - гарантирует, что если транзакция прочитала данные, то при повторном чтении она увидит те же данные (даже если другие транзакции изменили и зафиксировали эти данные). Однако новые строки (фантомы) могут появляться. Предотвращает грязное и неповторяющееся чтение.
- Serializable (Сериализуемый) - гарантирует, что результат параллельного выполнения транзакций такой же, как если бы они выполнялись последовательно (одна за другой). Достигается за счет строгих блокировок или многовариантного управления версиями (MVCC) с проверкой на конфликты. Предотвращает все аномалии.

Установка уровня изоляции:
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

<h4>Работа с транзакциями</h4>

Команды TCL:
- `START TRANSACTION` - начало транзакции
- `COMMIT` - завершение транзакции с сохранением изменений
- `ROLLBACK` - завершение транзакции с отменой изменений
- `SAVEPOINT `- точка сохранения в транзакции

Пример использования:
```sql
BEGIN TRANSACTION;
INSERT INTO table1 VALUES (1);
SAVEPOINT savepoint1;
INSERT INTO table1 VALUES (2);
ROLLBACK TO savepoint1; -- Вторая вставка откатывается, первая остается.
COMMIT;                 -- Сохраняется только первая вставка.
```

<h4>Механизмы обеспечения ACID в распределенных системах</h4>

В распределенных системах обеспечение ACID становится сложнее, потому что данные находятся на нескольких узлах, и нужно координировать транзакции между ними:
- Атомарность - протокол двухфазной фиксации (2PC): узел-координатор отправляет команду подготовки к транзакции другим узлам, транзакция выполняется всеми узлами до точки фиксации, изменения записываются во временный журнал. Затем узлы отправляют координатору о готовности завершения транзакции, если хотя бы один из узлов не готов - транзакция откатывается.
- Согласованность - в зависимости от системы используются разные модели согласованности. Для обеспечения строгой согласованности используются консенсус-алгоритмы (Paxos, Raft). Если доступ к данных важнее используется согласованность в конечном счете - данные асинхронно копируются на зависимые узлы.
- Изоляция - использование снимков состояния: используется глобальный временной штамп для определения согласованного снимка данных across узлов.
- Долговечность - обеспечивается засчет репликации данных на другие узлы.

<h3>3. Индексы</h3>

Индекс в SQL — это специальная структура данных, которая ускоряет операции извлечения данных из таблицы за счет уменьшения количества строк, которые необходимо просматривать. Лучше использовать индексы для столбцов, часто использующихся в `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`, а также обладающих большим количеством уникальных значений. Не рекомендуется использовать индексы на часто обновляемых полях.

Преимущества:
- Ускорение поиска: Позволяют быстро находить данные без полного сканирования таблицы.
- Оптимизация сортировки: Ускоряют `ORDER BY` и `GROUP BY`.
- Поддержка уникальности: Гарантируют отсутствие дубликатов (уникальные индексы).
- Эффективные `JOIN`: Ускоряют соединения таблиц по ключам.

Ограничения:
- Занимают дополнительное место на диске.
- Замедляют операции `INSERT`, `UPDATE`, `DELETE` (индексы нужно перестраивать).

Типы индексов:
- B-tree - Стандартный индекс для диапазонных запросов и сортировки. Подходит для большинства случаев (числа, строки, даты).
- Hash - Использует хеш-функции, работает только для точного поиска (=). Быстрее B-tree для =, но не поддерживает диапазоны (>, <).
- Bitmap - Хранит битовые карты для каждого значения. Эффективен для столбцов с малым числом уникальных значений (например, «пол»).
- Full-Text - Оптимизирован для поиска по тексту. Используется в WHERE text_column LIKE '%keyword%'.
- Составной - Создается на несколько столбцов. Эффективен, если в запросах используются несколько полей.
- Покрывающий - Содержит все данные запроса, избегая обращения к таблице. Ускоряет SELECT, если индекс включает все нужные столбцы.

<h4>Создание индексов различных типов</h4>

```sql
CREATE INDEX index_name ON table_name(column_name)               -- B-tree индекс
CREATE UNIQUE INDEX index_name ON table_name(column_name)        -- Уникальный индекс
CREATE INDEX index_name ON table_name(col1, col2, col3)          -- Составной индекс
CREATE INDEX index_name ON table_name USING HASH(column_name)    -- Hash индекс
CREATE FULLTEXT INDEX index_name ON table_name(column_name)      -- Полнотекстовый индекс
```

<h3>4. Партицирование таблиц</h3>

Партицирование — это метод разделения большой таблицы на меньшие, более управляемые части (партиции) на основе определённых правил. Каждая партиция хранится как отдельный физический объект, но логически представляет собой единую таблицу.

Преимущества:
- Ускорение запросов, которые затрагивают только определенные партиции
- Упрощение операций с данными (архивация, удаление)
- Возможность работать с отдельными партициями независимо
- Размещение "горячих" и "холодных" данных на разных носителях

<h4>Партицирование по диапазону значений</h4>

Создание таблицы с партициями:
```sql
CREATE TABLE sales (
    sale_id INT AUTO_INCREMENT,
    sale_date DATE NOT NULL,
    customer_id INT,
    amount DECIMAL(10,2),
    PRIMARY KEY (sale_id, sale_date)
) PARTITION BY RANGE COLUMNS(sale_date) (
    PARTITION p_2023_01 VALUES LESS THAN ('2023-02-01'),
    PARTITION p_2023_02 VALUES LESS THAN ('2023-03-01'),
    PARTITION p_2023_03 VALUES LESS THAN ('2023-04-01'),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

Добавление партиций:
```sql
ALTER TABLE sales REORGANIZE PARTITION p_future INTO (
    PARTITION p2023_04 VALUES LESS THAN ('2023-05-01'),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

Удаление партиций:
```sql
-- Удаление партиции и данных
ALTER TABLE sales DROP PARTITION p2020;

-- Удаление данных из партиции без удаления самой партиции
ALTER TABLE sales TRUNCATE PARTITION p2021;
```

<h3>5. Оптимизация запросов</h3>
<h4>Запросы с IN, NOT IN</h4>

Система проверяет каждое значение из списка, что может быть медленно, также, если в подзапросе с `NOT IN` есть `NULL`, то результатом будет `FALSE`. Для подобных подзапросов СУБД может использовать медленный алгоритм. Для решения данной проблемы есть несколько решений:

Использование `EXISTS`:

```sql
-- Было
SELECT *
  FROM Orders
 WHERE CustomerID IN
       (SELECT CustomerID
          FROM Customers
         WHERE Region = 'EU');

-- Стало
SELECT *
  FROM Orders AS o
 WHERE EXISTS
       (SELECT 0
          FROM Customers AS c
         WHERE c.CustomerID = o.CustomerID
           AND c.Region = 'EU');
```
Использование `LEFT JOIN` с условием (для `NOT IN`):

```sql
-- Было
SELECT * FROM Orders
 WHERE CustomerID NOT IN
       (SELECT CustomerID
         FROM Customers);

-- Стало
SELECT o.* 
  FROM Orders AS o
       LEFT JOIN Customers AS c
       ON o.CustomerID = c.CustomerID
 WHERE c.CustomerID IS NULL;
```

<h4>Запросы с JOIN</h4>

Для оптимизации запросов с `JOIN` можно применять следующее:
- Создавать индексы на столбцах, участвующих в `JOIN` (внешние ключи).
- Упорядочивать таблицы в `JOIN` начиная с самой маленькой или самой селективной таблицы.
- Использовать предварительную фильтрацию

Пример (изменение порядка в `JOIN` и предварительная фильтрация):
```sql
-- Было
SELECT *
  FROM Orders AS o
       JOIN Customers c ON o.CustomerID = c.CustomerID
 WHERE o.OrderDate > '2023-01-01';

-- Стало
SELECT *
  FROM Customers AS c
       JOIN
       (SELECT *
          FROM Orders
         WHERE OrderDate > '2023-01-01') AS o
       ON o.CustomerID = c.CustomerID;
```

<h4>Запросы с временными таблицами</h4>

Временные таблицы используются когда нужно разбить сложный запрос на несколько шагов и когда один набор данных используется многократно. Для оптимизации запросов с ними рекомендуется применять следующее:
- Создавать индексы на временных таблицах.
- Использовать `SELECT ... INTO` или `CREATE TABLE ... AS` вместо `INSERT ... SELECT`, если это позволяет СУБД.
- Анализировать данные во временной таблице с помощью команды `ANALYZE`.

Пример:
```sql
-- Шаг 1: Создаем временную таблицу с отфильтрованными заказами
SELECT OrderID, CustomerID, Amount
  INTO #FilteredOrders
  FROM Orders
 WHERE OrderDate > '2023-01-01';

-- Создаем индекс для быстрого JOIN
CREATE INDEX idx_temp ON #FilteredOrders (CustomerID);

-- Шаг 2: Используем ее в соединении
SELECT c.CustomerName, SUM(fo.Amount)
  FROM Customers AS c
       JOIN #FilteredOrders AS fo ON c.CustomerID = fo.CustomerID
 GROUP BY c.CustomerName;
```

<h4>Запросы с материализованными представлениями</h4>

Для оптимизации запросов с материализованными представлениями следует использовать индексы для более быстрой выборки из представления:

```sql
-- Создание MV с агрегированными данными
CREATE MATERIALIZED VIEW mv_sales_summary AS
SELECT
    ProductID,
    DATE_TRUNC('month', OrderDate) as OrderMonth,
    SUM(Amount) as TotalAmount,
    COUNT(*) as OrderCount
FROM Orders
GROUP BY ProductID, DATE_TRUNC('month', OrderDate);

-- Быстрый запрос к MV
SELECT * FROM mv_sales_summary WHERE ProductID = 123;
```

<h4>Запросы с оконными функциями</h4>

Для оптимизации следует делать следующее:
- Создавать правильные индексы. Идеальный индекс для оконной функции должен содержать столбцы в том же порядке: `PARTITION BY ... ORDER BY`.
- Фильтровать после применения оконной функции, используя CTE (Common Table Expression) или подзапрос.
- Использовать временные таблицы для многоэтапных расчетов. Если есть несколько оконных функций с разными `PARTITION BY`, иногда эффективнее разнести их по разным временным таблицам с индексами, чем выполнять все в одном запросе.

<h4>Анализ плана запроса с помощью EXPLAIN</h4>

План выполнения запроса — это последовательность операций, которую СУБД выполняет для получения результата запроса. Он показывает, как будут сканироваться таблицы (последовательно, по индексу и т.д.), как будут соединяться таблицы, будут ли использоваться временные таблицы, сортировки и т.д.
В большинстве СУБД есть команда `EXPLAIN`, которая показывает план выполнения без фактического выполнения запроса. А `EXPLAIN ANALYZE` выполняет запрос и показывает реальные показатели (время, количество строк и т.д.).
Ключевые элементы плана выполнения:
- Узлы (Nodes): Каждый шаг в плане называется узлом. Например, Seq Scan, Index Scan, Hash Join, Sort и т.д.
- Оценка стоимости (Cost): Планировщик оценивает стоимость операции. Обычно состоит из двух чисел: начальная стоимость и общая стоимость.
- Оценка количества строк (Rows): Сколько строк ожидает оптимизатор на этом шаге.
- Оценка размера (Width): Средний размер строки в байтах.
- Фактическое время (Actual Time): Фактическое время выполнения шага (в миллисекундах).
- Фактическое количество строк (Actual Rows): Реальное количество строк, обработанных на шаге.
- Циклы (Loops): Сколько раз выполнялся этот шаг (например, для внутренних операций вложенного цикла).

Типы узлов (операций) в плане:
- Сканирование (`Scan`):
  - `Seq Scan` (последовательное сканирование) — чтение всей таблицы.
  - `Index Scan` — сканирование по индексу (выбирает все строки по порядку индекса).
  - `Index Only Scan` — сканирование только индекса, если все данные есть в индексе.
  - `Bitmap Heap Scan` — использование битовой карты для фильтрации строк.
- Соединение (`Join`):
  - `Nested Loop` — вложенный цикл. Подходит для маленьких наборов данных.
  - `Hash Join` — построение хеш-таблицы по одной таблице и probing по другой.
  - `Merge Join` — соединение слиянием, требует отсортированных данных.
- Агрегация (`Aggregation`):
  - `HashAggregate` — агрегация с использованием хеш-таблицы.
  - `GroupAggregate` — агрегация с предварительной сортировкой.
- Сортировка (`Sort`):
  - `Sort` — сортировка данных.
- Прочее:
  - `Limit` — ограничение количества строк.
  - `Unique` — удаление дубликатов.
  - `CTE Scan` — сканирование Common Table Expression.

Пример применения:
```sql
EXPLAIN ANALYZE
SELECT o.order_id, c.customer_name 
FROM orders o 
JOIN customers c ON o.customer_id = c.customer_id 
WHERE o.total_amount > 1000;
```

Вывод:
```
Hash Join  (cost=129.57..273.23 rows=2548 width=36) (actual time=1.234..4.567 rows=2150 loops=1)
  Hash Cond: (o.customer_id = c.customer_id)
  ->  Seq Scan on orders o  (cost=0.00..112.45 rows=2548 width=8) (actual time=0.012..1.234 rows=2150 loops=1)
        Filter: (total_amount > 1000)
        Rows Removed by Filter: 7850
  ->  Hash  (cost=65.43..65.43 rows=2543 width=36) (actual time=1.210..1.210 rows=2500 loops=1)
        Buckets: 4096  Batches: 1  Memory Usage: 201kB
        ->  Seq Scan on customers c  (cost=0.00..65.43 rows=2543 width=36) (actual time=0.008..0.645 rows=2500 loops=1)
Planning Time: 0.156 ms
Execution Time: 4.789 ms
```

Интерпретация плана:
- Читаем план сверху вниз и с отступами (дерево): Операции с отступами являются дочерними и выполняются первыми.
- Обращаем внимание на самые дорогие операции: Обычно это операции с наибольшим cost и actual time.
- Сравниваем оценки и факт: Если планировщик сильно ошибся в оценках количества строк (rows), это может указывать на устаревшую статистику или сложность предикатов.
- Ищем узкие места:
  - Полное сканирование больших таблиц (Seq Scan) без индексов.
  - Сортировки (Sort) больших объемов данных.
  - Хеш-соединения (Hash Join) или соединения слиянием (Merge Join) с большим количеством строк.

Советы по оптимизации на основе плана:
- Если видим `Seq Scan` по большой таблице, возможно, нужно добавить индекс.
- Если планировщик ошибается в оценках строк, обновите статистику: `ANALYZE table_name`; (в PostgreSQL).
- Если видим дорогой `Sort`, посмотрите, можно ли использовать индекс для избежания сортировки.
- Для соединений убедитесь, что столбцы соединения индексированы.
- Обратите внимание на использование памяти (например, в `Hash Join` или `Sort`). Если памяти не хватает, операция может уйти на диск (дисковый ввод-вывод), что медленно.
- Используйте подсказки по индексам (если СУБД позволяет) или перепишите запрос, чтобы использовать более эффективный индекс.

<h4>Подсказки для оптимизации</h4>

Подсказки — это специальные инструкции, которые мы даем СУБД, чтобы повлиять на план выполнения запроса. Они используются, когда оптимизатор SQL по какой-то причине не выбирает оптимальный план. Рассмотрим подсказки в Oracle и PostgreSQL (с установленным расширением `pg_hint_plan`).

Использование конкретного алгоритма соединения:
```sql
SELECT /*+ USE_HASH(e d) */ *
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

SELECT /*+ USE_NL(e d) */ *
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

SELECT /*+ USE_MERGE(e d) */ *
FROM employees e
JOIN departments d ON e.department_id = d.department_id;
```

Порядок соединения:
```sql
SELECT /*+ ORDERED */ *
FROM small_table s, large_table l
WHERE s.id = l.small_id;
-- Заставляет соединять в порядке таблиц в FROM
```

Использование индекса:
```sql
SELECT /*+ INDEX(orders IX_ORDERS_CUSTOMER_DATE) */ *
FROM orders 
WHERE customer_id = 123 AND order_date > SYSDATE - 30;

SELECT /*+ FULL(orders) */ * -- Не использовать
FROM orders 
WHERE total_amount < 100;
```

<h3>6. Представления</h3>
<h4>Обычные представления</h4>

Представление (View) — это виртуальная таблица, результат запроса, который сохранен в базе данных под определенным именем. Например, для БД с таблицами `Employees`, `Departments` и `Salaries` можно создать представление `Active_Employees_Info`, которое будет показывать только имя, должность и отдел для всех активных сотрудников, скрывая их зарплату и другую конфиденциальную информацию. Представления могут взаимодейтвовать с другими таблицами и представлениями точно также, как и обычные таблицы.

Особенности:
- Не хранит данные: Представление само по себе не содержит данных. Оно хранит только определение (SQL-запрос). При каждом обращении к представлению выполняется этот запрос, и возвращаются актуальные данные из базовых таблиц.
- Права доступа: Работа с представлением регулируется правами доступа. Пользователь может иметь доступ к представлению, но не к исходным таблицам.

Преимущества использования представлений:
- Безопасность - можно скрыть конфиденциальные столбцы или строки. Например, предоставить доступ к представлению с именами сотрудников, но без их зарплат.
- Упрощение сложных запросов - если есть сложный запрос с множеством JOIN и подзапросов, можно инкапсулировать его в представление. После этого пользователи могут делать простой SELECT * FROM complex_view, не вдаваясь в детали.
- Согласованность логики - бизнес-логика записывается в представление один раз и используется повсеместно. Это предотвращает дублирование кода и ошибки.
- Абстракция данных - если структура базовых таблиц изменяется, можно изменить представление так, чтобы оно продолжало возвращать те же данные, и старые запросы, использующие это представление, не сломаются.

Создание представления:
```sql
CREATE VIEW German_Customers AS
SELECT CustomerName, ContactName, Email
FROM Customers
WHERE Country = 'Germany';
```

Изменение представления:
```sql
ALTER VIEW German_Customers AS
SELECT CustomerName, ContactName, Email, City, Phone
FROM Customers
WHERE Country = 'Germany';
```

Удаление представления:
```sql
DROP VIEW German_Customers;
```

Изменяемые представления - это обычные (не материализованные) представления, через которые можно выполнять операции модификации данных (`INSERT`, `UPDATE`, `DELETE`), и эти изменения применяются к базовым таблицам. Для того чтобы представление было изменяемым оно должно быть основано на одной базовой таблице и не содержать:
- Группировку и агрегатные функции
- Оконные функции
- Операторы работы с множествами
- Подзапросы в `SELECT`

<h4>Материализованные представления</h4>

Материализованное представление — это объект базы данных, который хранит результат запроса в виде физических данных, подобно таблице. В отличие от обычного представления, которое каждый раз выполняет запрос при обращении, материализованное представление хранит данные на диске и обновляется по расписанию или вручную.

Отличия от обычных представлений:
- Хранение данных - обычное представление не хранит данные.
- Актуальность данных - материализованное представление может содержать устаревшие данные до следующего обновления.
- Производительность - материализованные представления могут быть быстрее для сложных запросов, так как данные уже предварительно вычислены.
- Обновление - материализованные представления нужно обновлять.

Преимущества:
- Высокая производительность для сложных запросов.
- Снижение нагрузки на источник данных.
- Возможность индексирования материализованных данных.

Ограничения:
- Данные могут быть неактуальными.
- Требуется место для хранения данных.
- Процесс обновления может быть ресурсоемким.

Материализованные представления создаются подобно обычным, но добавляется ключевое слово `MATERIALIZED`:
```sql
CREATE MATERIALIZED VIEW German_Customers AS
SELECT CustomerName, ContactName, Email
FROM Customers
WHERE Country = 'Germany';
```

Материализованные представления могут обновляться двумя основными способами: полное обновление (complete refresh) и инкрементальное обновление (fast refresh).
- Полное обновление перестраивает все материализованное представление заново. Это может быть ресурсоемко и долго, но гарантирует актуальность данных.
- Инкрементальное обновление применяет только изменения, которые произошли в базовых таблицах с момента последнего обновления. Для этого необходимо, чтобы материализованное представление было создано с поддержкой инкрементального обновления, и обычно требуются журналы изменений (materialized view logs) для базовых таблиц.

Для обновления данных материализованного представления используется команда:
```sql
REFRESH MATERIALIZED VIEW German_Customers;
```

Автоматическое обновление (Oracle):
```sql
CREATE MATERIALIZED VIEW mv_sales
REFRESH COMPLETE     -- или FAST
START WITH SYSDATE   -- время первого обновления
NEXT SYSDATE + 1/24  -- каждые 60 минут
AS SELECT ...;

-- По коммиту (только FAST refresh)
CREATE MATERIALIZED VIEW mv_sales
REFRESH FAST ON COMMIT
AS SELECT ...;
```

Инкрементальное обновление (Oracle):
```sql
CREATE MATERIALIZED VIEW mv_sales
REFRESH FAST ON DEMAND
AS
SELECT product_id, SUM(quantity) as total_quantity
FROM sales
GROUP BY product_id;

--View log для таблицы sales
CREATE MATERIALIZED VIEW LOG ON sales
WITH ROWID, SEQUENCE (product_id, quantity)
INCLUDING NEW VALUES;
```

Поскольку материализованные представления хранят данные, мы можем создавать индексы на них для ускорения запросов. Это особенно полезно, если запросы к материализованному представлению сами по себе сложны. Индексы на материализованных представлениях ускоряют выполнение запросов к ним, но замедляют процесс обновления (как полного, так и инкрементального), потому что при обновлении представления индексы приходится также обновлять.

Настройки SQL сервера могут влиять на производительность материализованных представлений. Например:
- Настройки, связанные с памятью (например, размер буферного кэша) могут ускорить обновление материализованных представлений.
- Параллельное выполнение запросов может ускорить построение материализованных представлений.
- Настройки журналирования и восстановления могут влиять на производительность при инкрементальном обновлении.

<h3>7. Алгоритмы соединения таблиц</h3>

СУБД использует разлмчные алгоритмы для соединения таблиц в зависимости от задачи.

<h4>Nested Loop Join</h4>

Простой обход с помощью двух вложенных циклов. Сложность: `O(N * M)`

Алгоритм:
1. Внешний цикл: Берется одна таблица (называемая внешней, или outer table). Перебирается каждая строка этой таблицы.
2. Внутренний цикл: Для каждой строки внешней таблицы полностью перебирается вторая таблица (называемая внутренней, или inner table).
3. Проверка условия: Для каждой пары строк (одна из внешней таблицы, одна из внутренней) проверяется условие соединения. Если условие истинно, строки добавляются в результирующий набор.

Псевдокод:
```python
for row_outer in outer_table:
    for row_inner in inner_table:
        if (join_condition is true):
            output (row_outer, row_inner)
```

Когда эффективен:
- Когда одна из таблиц очень мала (например, содержит всего несколько десятков строк).
- Когда во внутренней таблице есть индекс по столбцу соединения. В этом случае внутренний цикл превращается не в полное сканирование таблицы, а в быстрое сканирование по индексу (`O(log M)`), что радикально ускоряет процесс. Общая сложность становится `~O(N * log M)`.

<h4>Block Nested Loop Join</h4>

Оптимизированная версия обычного Nested Loop Join. Основная проблема NLJ — это огромное количество обращений к диску (I/O операций), так как каждая строка внешней таблицы требует полного чтения внутренней таблицы. BNL решает эту проблему, уменьшая количество чтений внутренней таблицы. Сложность: `O(N * M)`, но с гораздо меньшей константой для чтения внешней таблицы.

Алгоритм:
1. Буферизация внешней таблицы: Вместо того чтобы брать по одной строке из внешней таблицы, СУБД загружает в оперативную память блок строк (например, 100 строк) из внешней таблицы. Этот блок часто помещается в буферный кэш (Buffer Pool).
2. Сканирование внутренней таблицы: Затем СУБД однократно сканирует всю внутреннюю таблицу.
3. Сравнение блока с каждой строкой: Для каждой строки внутренней таблицы СУБД сравнивает ее не с одной строкой из внешней таблицы, а со всем блоком загруженных строк. Если для какой-либо строки в блоке условие соединения выполняется, пара строк добавляется в результат.
4. Цикл: Процесс повторяется для следующего блока строк из внешней таблицы, пока все строки не будут обработаны.

Псевдокод:
```python
for block_of_outer_rows in outer_table:
    load block into memory
    for row_inner in inner_table:
        for row_outer in block_of_outer_rows:
            if (join_condition is true):
                output (row_outer, row_inner)
```

Когда эффективен:
- Когда ни одна из таблиц не является очень маленькой, но при этом нет индекса на столбце соединения во внутренней таблице.
- Когда размер блока (буфера) достаточно велик, чтобы вместить значительную часть внешней таблицы. Это максимально сокращает количество сканирований внутренней таблицы.

<h4>Hash Join</h4>

Hash Join — это алгоритм соединения, который использует хеш-таблицу для объединения двух наборов данных. Сложность: `O(N + M)`

Алгоритм:
1. Фаза построения (Build Phase):
  - Выбирается одна таблица (обычно меньшая) в качестве "строящей" (build table)
  - Для каждой строки строящей таблицы вычисляется хеш-значение ключа соединения
  - Строка помещается в хеш-таблицу, где ключом является хеш-значение, а значением — сама строка
2. Фаза проверки (Probe Phase):
  - Сканируется вторая таблица - "проверяющая" (probe table)
  - Для каждой строки проверяющей таблицы вычисляется хеш-значение ключа соединения
  - По этому хеш-значению ищется совпадение в хеш-таблице
  - Если найдена запись с таким же хеш-значением, выполняется точное сравнение ключей (на случай коллизий хешей)
  - При совпадении строки объединяются в результат

Псевдокод:
```python
# Фаза построения
hash_table = {}
for build_row in build_table:
    hash_key = hash(build_row.join_column)
    add build_row to hash_table[hash_key]

# Фаза проверки
for probe_row in probe_table:
    hash_key = hash(probe_row.join_column)
    for build_row in hash_table[hash_key]:
        if build_row.join_column == probe_row.join_column:
            output (build_row, probe_row)
```

Когда эффективен:
- Когда соединяются большие таблицы
- Когда отсутствуют индексы, так как алгоритм хорошо работает и без них
- Когда используется соединение по равенству

<h4>Grace Hash Join</h4>

Усовершенствованная версия Hash Join, предназначенная для обработки очень больших таблиц, которые не помещаются в оперативной памяти.

Алгоритм:
1. Фаза разбиения (Partitioning Phase):
  - Обе таблицы разбиваются на K партиций с помощью одной и той же хеш-функции
  - Каждая партиция записывается на диск
  - Ключевое свойство: все потенциально совпадающие строки попадают в партиции с одинаковыми номерами
2. Фаза соединения (Join Phase). Hash Join для каждой пары соответствующих партиций:
  - Загружается партиция строящей таблицы в память и строится хеш-таблица
  - Сканируется партиция проверяющей таблицы и выполняется probe против хеш-таблицы
  - Результаты соединения добавляются в общий результат

Псевдокод:
```python
# Фаза разбиения
partitions_build = [ [] for _ in range(K) ]
partitions_probe = [ [] for _ in range(K) ]

# Разбиваем строящую таблицу
for each build_row in build_table:
    partition_id = hash1(build_row.join_column) % K
    add build_row to partitions_build[partition_id]

# Разбиваем проверяющую таблицу
for each probe_row in probe_table:
    partition_id = hash1(probe_row.join_column) % K
    add probe_row to partitions_probe[partition_id]

# Фаза соединения (Hash Join для каждой пары соответствующих партиций)
for i in range(K):
    # Строим хеш-таблицу для i-й партиции строящей таблицы
    hash_table = {}
    for build_row in partitions_build[i]:
        hash_key = hash2(build_row.join_column)
        add build_row to hash_table[hash_key]

    # Проверяем i-ю партицию проверяющей таблицы
    for probe_row in partitions_probe[i]:
        hash_key = hash2(probe_row.join_column)
        for build_row in hash_table[hash_key]:
            if build_row.join_column == probe_row.join_column:
                output (build_row, probe_row)
```

Когда эффективен:
- Когда соединяются очень большие таблицы и хеш-таблица не помещается в оперативной памяти
- Когда отсутствуют индексы, так как алгоритм хорошо работает и без них
- Когда используется соединение по равенству

<h4>Merge Join</h4>

Merge Join — это алгоритм, который работает по принципу слияния двух отсортированных наборов данных. Сложность: `O(N + M)` для отсортированных данных, иначе - `O(N log N + M log M)`.

Алгоритм:
1. Сортировка (если необходимо):
  - Если обе таблицы не отсортированы по ключу соединения, то сначала они сортируются. Это может быть дорогостоящей операцией, но если есть индекс по ключу соединения, то данные уже отсортированы, и сортировка не требуется.
2. Слияние (Merge):
  - Указатели устанавливаются на начало обеих таблиц.
  - Затем происходит последовательное сравнение ключей соединения из обеих таблиц.
  - Если ключи совпадают, строки объединяются и добавляются в результат.
  - Если ключ в первой таблице меньше, указатель в первой таблице перемещается вперед.
  - Если ключ во второй таблице меньше, указатель во второй таблице перемещается вперед.

Псевдокод:
```python
# Предполагаем, что обе таблицы уже отсортированы по join_key
pointer_A = 0  # для таблицы A
pointer_B = 0  # для таблицы B

while pointer_A < len(table_A) and pointer_B < len(table_B):
    key_A = table_A[pointer_A].join_key
    key_B = table_B[pointer_B].join_key
    if key_A == key_B:
        # Сохраняем текущую позицию в таблице B для backtracking
        temp_B = pointer_B
        # Для всех строк в A с одинаковым ключом
        while pointer_A < len(table_A) and table_A[pointer_A].join_key == key_A:
            pointer_B = temp_B
            while pointer_B < len(table_B) and table_B[pointer_B].join_key == key_B:
                output (table_A[pointer_A], table_B[pointer_B])
                pointer_B += 1
            pointer_A += 1
    elif key_A < key_B:
        pointer_A += 1
    else:
        pointer_B += 1
```

Когда эффективен:
- Когда соединяются большие отсортированные или индексированные наборы данных
- Когда используется соединение по неравенству или интервалу

<h4>Adaptive Join</h4>

Adaptive Join — гибридный алгоритм, который динамически выбирает стратегию выполнения во время работы запроса. Он особенно популярен в колоночных хранилищах и современных СУБД.

Алгоритм:
1. Начальная фаза: Алгоритм начинает выполнение с одной стратегии (обычно Nested Loop Join для быстрого получения первых строк)
2. Мониторинг: Во время выполнения отслеживаются метрики (количество обработанных строк, скорость выполнения)
3. Принятие решения: На основе собранной статистики алгоритм решает, продолжать текущую стратегию или переключиться на другую
4. Переключение: При необходимости выполняется плавное переключение на более оптимальную стратегию

Псевдокод (переключение с Nested Loop Join на Hash Join):
```python
threshold = 1000  # порог для переключения
processed_rows = 0

# Начинаем с Nested Loop для быстрого возврата первых строк
for outer_row in outer_table:
    found_match = False

    for inner_row in inner_table:
        if join_condition(outer_row, inner_row):
            output(outer_row, inner_row)
            found_match = True
            break  # или продолжить для всех совпадений

    processed_rows += 1
    if processed_rows >= threshold and not found_match:
        build_hash_table(inner_table)
        continue_with_hash_join(outer_table[processed_rows:])
        break
```

Когда эффективен:
- Когда используется система с изменяющейся нагрузкой
- Когда требуется быстро вывести первые строки