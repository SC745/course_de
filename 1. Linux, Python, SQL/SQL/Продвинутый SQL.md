<h2>Продвинутый SQL</h2>
<h3>1. Хранимые процедуры, функции и триггеры</h3>
<h4>Хранимые процедуры</h4>

Хранимая процедура (Stored Procedure) — это заранее подготовленный и сохраненный в базе данных набор SQL-инструкций, который выполняется как единое целое. Её можно рассматривать как аналог функции или метода в процедурных языках программирования.

Для чего нужны:
- Инкапсуляция логики: Сложная бизнес-логика прячется внутри процедуры. Клиентскому приложению нужно только вызвать её, не зная деталей реализации.
- Производительность: Снижается сетевой трафик (передается только вызов, а не множество отдельных запросов). Сервер кэширует план выполнения процедуры.
- Безопасность: Можно дать пользователю права на выполнение процедуры, даже если у него нет прямых прав на таблицы, с которыми она работает.
- Целостность данных: Группа операций может быть объединена в транзакцию внутри процедуры, что гарантирует согласованность данных.

Создание и вызов процедуры:
```sql
-- Процедура, которая добавляет нового клиента
CREATE PROCEDURE AddNewCustomer(
    IN p_CustomerName VARCHAR(100),
    IN p_ContactEmail VARCHAR(100),
    OUT p_NewCustomerID INT
)
BEGIN
    -- Вставляем новую запись
    INSERT INTO Customers (CustomerName, ContactEmail)
    VALUES (p_CustomerName, p_ContactEmail);
    -- Получаем ID нового клиента и возвращаем его через OUT-параметр
    SET p_NewCustomerID = LAST_INSERT_ID();
END;

-- Вызов процедуры
CALL AddNewCustomer('ООО "Вектор"', 'info@vector.ru', @NewID);

-- Использование возвращенного значения
SELECT @NewID as NewCustomerID;
```

Параметры процедур бывают трех типов:
- IN параметры: передаются в процедуру, но их изменение внутри процедуры не видно снаружи.
- OUT параметры: не передаются в процедуру (хотя синтаксис вызова может требовать указания переменной), но их значение устанавливается внутри процедуры и становится доступным вызывающей стороне.
- INOUT параметры: комбинация — передаются в процедуру и могут быть изменены.

<h4>Хранимые функции</h4>

Хранимая функция (Stored Function, или User-Defined Function - UDF) — это подпрограмма, которая возвращает единственное значение (скаляр) или таблицу. Ключевое отличие — функция предназначена для вычисления значения и использования его внутри SQL-выражений.

Для чего нужны:
- Модульность и повторное использование: Сложные расчеты или преобразования данных выносятся в функцию.
- Использование в запросах: Функцию можно использовать в `SELECT`, `WHERE`, `JOIN` и других частях SQL-запроса, как встроенные функции (`UPPER()`, `SUM()`).

Создание и вызов функции:
```sql
-- Функция, которая вычисляет общую сумму заказа
CREATE FUNCTION GetOrderTotalAmount(p_OrderID INT)
RETURNS DECIMAL(10,2)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE total DECIMAL(10,2);

    SELECT SUM(UnitPrice * Quantity)
    INTO total
    FROM OrderDetails
    WHERE OrderID = p_OrderID;

    RETURN total;
END;

-- Использование в SELECT
SELECT
    OrderID,
    GetOrderTotalAmount(OrderID) as TotalAmount
FROM Orders
WHERE OrderID = 12345;

-- Использование в WHERE
SELECT OrderID
FROM Orders
WHERE GetOrderTotalAmount(OrderID) > 1000;
```

Детали определения:
- `RETURNS` — указывает тип данных возвращаемого значения.

- `DETERMINISTIC` / `NOT DETERMINISTIC`: Детерминированная функция всегда возвращает один и тот же результат для одних и тех же входных параметров (например, `UPPER()`). Недетерминированная — может возвращать разный результат (например, функция, использующая `CURRENT_TIMESTAMP`).

- `READS SQL DATA` — указывает, что функция только читает данные. Бывают также `MODIFIES SQL DATA` и др.

Сравнение с процедурой:
- Не может управлять транзакциями
- Может вызываться как часть SQL выражения (В `SELECT`, `WHERE`, `HAVING` и др.)
- Всегда возвращает одно значение, процедура может возвращать ничего или несколько значений
- В большинстве СУБД не может выполнять DML операции

<h3>2. Транзакции</h3>

Транзакция в SQL — это логическая единица работы с базой данных, которая состоит из последовательности операций, выполняемых как единое целое.

Принципы ACID:
- Атомарность (Atomicity): Транзакция выполняется целиком или не выполняется вовсе. При ошибке все изменения откатываются.
- Согласованность (Consistency): Транзакция переводит базу данных из одного целостного состояния в другое (например, не нарушаются ограничения целостности).
- Изоляция (Isolation): Параллельные транзакции не влияют друг на друга. Уровни изоляции (например, `READ COMMITTED`, `SERIALIZABLE`) регулируют степень видимости изменений между транзакциями.
- Долговечность (Durability): После завершения транзакции (коммита) изменения сохраняются даже при сбое системы.

<h4>Уровни изоляции транзакций</h4>

Уровни изоляции определены в стандарте SQL (ANSI/ISO) и включают четыре уровня. Они предназначены для управления видимостью изменений, сделанных в одной транзакции, для других параллельных транзакций. Каждый уровень изоляции предотвращает определенные аномалии, но за более высокий уровень изоляции приходится платить производительностью (из-за блокировок или механизмов управления версиями).

Некоторые аномалии которые могут возникнуть при разных уровнях изоляции:
- Потерянное обновление (Lost Update): Две транзакции одновременно обновляют одни и те же данные, и одно из обновлений теряется (перезаписывается другим).
- Грязное чтение (Dirty Read): Транзакция читает незафиксированные изменения другой транзакции. Если та транзакция откатывается, то первая транзакция прочитала данные, которых никогда не было.
- Неповторяющееся чтение (Non-repeatable Read): Транзакция дважды читает одни и те же данные, но получает разные значения, потому что другая транзакция изменила и зафиксировала эти данные между чтениями.
- Фантомное чтение (Phantom Read): Транзакция повторно выполняет запрос, возвращающий набор строк по некоторому условию, и обнаруживает, что набор строк изменился из-за того, что другая транзакция добавила или удалила строки, удовлетворяющие условию, и зафиксировала изменения.

Уровни изоляции (от низкого к высокому):
- Read Uncommitted (Чтение незафиксированных данных) - транзакции видят незафиксированные изменения других транзакций. Не предотвращает аномалий.
- Read Committed (Чтение зафиксированных данных) - транзакция видит только зафиксированные изменения других транзакций. Предотвращает грязное чтение.
- Repeatable Read (Повторяемое чтение) - гарантирует, что если транзакция прочитала данные, то при повторном чтении она увидит те же данные (даже если другие транзакции изменили и зафиксировали эти данные). Однако новые строки (фантомы) могут появляться. Предотвращает грязное и неповторяющееся чтение.
- Serializable (Сериализуемый) - гарантирует, что результат параллельного выполнения транзакций такой же, как если бы они выполнялись последовательно (одна за другой). Достигается за счет строгих блокировок или многовариантного управления версиями (MVCC) с проверкой на конфликты. Предотвращает все аномалии.

Установка уровня изоляции:
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

<h4>Работа с транзакциями</h4>

Команды TCL:
- `START TRANSACTION` - начало транзакции
- `COMMIT` - завершение транзакции с сохранением изменений
- `ROLLBACK` - завершение транзакции с отменой изменений
- `SAVEPOINT `- точка сохранения в транзакции

Пример использования:
```sql
BEGIN TRANSACTION;
INSERT INTO table1 VALUES (1);
SAVEPOINT savepoint1;
INSERT INTO table1 VALUES (2);
ROLLBACK TO savepoint1; -- Вторая вставка откатывается, первая остается.
COMMIT;                 -- Сохраняется только первая вставка.
```

<h4>Механизмы обеспечения ACID в распределенных системах</h4>

В распределенных системах обеспечение ACID становится сложнее, потому что данные находятся на нескольких узлах, и нужно координировать транзакции между ними:
- Атомарность - протокол двухфазной фиксации (2PC): узел-координатор отправляет команду подготовки к транзакции другим узлам, транзакция выполняется всеми узлами до точки фиксации, изменения записываются во временный журнал. Затем узлы отправляют координатору о готовности завершения транзакции, если хотя бы один из узлов не готов - транзакция откатывается.
- Согласованность - в зависимости от системы используются разные модели согласованности. Для обеспечения строгой согласованности используются консенсус-алгоритмы (Paxos, Raft). Если доступ к данных важнее используется согласованность в конечном счете - данные асинхронно копируются на зависимые узлы.
- Изоляция - использование снимков состояния: используется глобальный временной штамп для определения согласованного снимка данных across узлов.
- Долговечность - обеспечивается засчет репликации данных на другие узлы.