<h2>Команды в терминале</h2>
<h3>1. Навигация</h3>

`pwd` - просмотреть текущую директорию

`ls` - список файлов и директорий
```bash
ls          # простой список
ls -l       # подробный список с правами, размерами, датами
ls -a       # показать скрытые файлы (начинающиеся с .)
ls -la      # комбинация -l и -a
ls -lh      # размеры в человеко-читаемом формате
```
`cd` - смена директории
```bash
cd /path     # перейти в указанный путь
cd ~         # перейти в домашнюю директорию
cd ..        # перейти на уровень выше
cd -         # вернуться в предыдущую директорию
```

<h3>2. Использование алиасов</h3>

Базовый синтаксис:
```bash
alias имя_алиаса='команда'
```

Примеры:
```bash
# Создание временного алиаса
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Использование
ll      # вместо ls -alF
la      # вместо ls -A

# Удаление
unalias ll
unalias -a     # удаление ВСЕХ алиасов
```
Алиасы, определенные в терминале, действительны в течении сессии пользователя. Для того чтобы они действовали всегда, их требуется добавить в конфигурационный файл используемой оболочки:
```bash
~/.bashrc                     #bash
~/.bash_profile               #bash
~/.zshrc                      #zsh
~/.config/fish/config.fish    #fish
```

Также можно создать файл с алиасами и использовать его:
1. Создать файл:

```bash
nano ~/.bash_aliases
```
2. Заполнить файл:

```bash
# ~/.bash_aliases

# Файловые операции
alias ll='ls -alFh'
alias la='ls -A'
alias l='ls -CF'

# Навигация
alias ..='cd ..'
alias ...='cd ../..'

# Git
alias gs='git status'
alias gp='git push'
```
3. Подключить файл в `~/.bashrc`:

```bash
# Добавьте в ~/.bashrc
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```

<h3>3. Создание и использование символических ссылок</h3>

Символические ссылки (symlinks) — это специальные файлы, которые указывают на другие файлы или директории. Они аналогичны ярлыкам в Windows.

Базовый синтаксис:
```bash
ln -s цель имя_ссылки
```

Примеры:
```bash
# Ссылка на файл
ln -s /path/to/original.txt link_to_file.txt
ln -s /path/to/original.txt /home/user/my_link.txt    # Ссылка в директории

# Ссылка на директорию
ln -s /path/to/original_directory link_to_directory
ln -s ~/Documents/my_project ./project_link    # Ссылка на домашнюю директорию
```

<h3>4. Перенаправление ввода/вывода и работа с пайпами</h3>

```bash
# > — перенаправление стандартного вывода (stdout) в файл (с перезаписью):
ls > file_list.txt  # Содержимое file_list.txt будет заменено списком файлов

# >> — перенаправление stdout в файл (с добавлением):
date >> log.txt  # Добавит текущую дату в конец log.txt

# 2> — перенаправление ошибок (stderr):
grep "error" /var/log/syslog 2> errors.log

# &> — перенаправление и stdout, и stderr:
python script.py &> output.log

# < — передача содержимого файла в стандартный ввод (stdin):
sort < unsorted_list.txt  # Отсортирует строки из файла

# | — передаёт вывод одной команды на вход другой:
ps aux | grep nginx           # Найдёт процессы, содержащие "nginx"
cat /var/log/auth.log | less  # Просмотр лога постранично
```

<h3>5. Сетевые команды для проверки доступности хостов</h3>

Ping - проверяет доступность хоста через ICMP-пакеты:
```bash
ping example.com
ping -c 4 192.168.1.1  # Ограничить число пакетов (4)
```

Traceroute - показывает путь пакетов до хоста:
```bash
traceroute google.com
tracepath google.com    # Упрощённая версия (не требует root)
```

Netcat (nc) - проверяет доступность порта:
```bash
nc -zv example.com 80   # Проверить порт 80 на example.com
nc -zv 192.168.1.1 22  # Проверить SSH-порт (22)
```

Curl - работает с сетевыми запросами:
```bash
curl -I http://example.com  # Заголовки ответа сервера
curl -s -o /dev/null -w "%{http_code}" example.com  # Только HTTP-код
```

```bash
Telnet - проверяет подключение к порту (устаревший, но полезный инструмент):
telnet example.com 80
```

<h3>6. Использование sudo</h3>

```bash
# Выполнение команды с правами root:
sudo apt update

# Выполнение команды от имени другого пользователя:
sudo -u username whoami  # Выполнит whoami как username
```

Ключевые опции:
```bash
# -i — запуск оболочки shell как целевой пользователь (аналогично входу в систему):
sudo -i -u username

# -s — запуск shell с привилегиями root (сохраняет текущее окружение):
sudo -s

# -l — список разрешённых команд для текущего пользователя:
sudo -l
```

<h3>6. Использование cron</h3>

Cron — это планировщик задач в Linux, который позволяет выполнять команды или скрипты по расписанию. `crontab` (cron table) — файл, в котором хранится расписание для пользователя. Формат записи:
```bash
минута час день_месяца месяц день_недели команда
```
Поля: минута (0-59), час (0-23), день_месяца (1-31), месяц (1-12), день_недели (0-7, где 0 и 7 — воскресенье).
Также можно использовать специальные символы:
- `*` — любое значение
- `,` — перечисление (например, 1,3,5)
- `-` — диапазон (например, 1-5)
- `*/n` — каждые n единиц времени (например, */5 — каждые 5 минут)

Редактирование crontab:
- Для текущего пользователя: `crontab -e`
- Просмотр текущих задач: `crontab -l`
- Удаление всех задач: `crontab -r`

Примеры:
```bash
# Ежедневно в 3:30:
30 3 * * * /path/to/script.sh

# Каждые 5 минут:
*/5 * * * * /path/to/script.sh

# Каждый понедельник в 9:00:
0 9 * * 1 /path/to/script.sh
```

<h3>7. Использование rsync</h3>

Rsync — утилита для синхронизации файлов и каталогов, поддерживающая копирование с минимальным использованием трафика (пересылаются только изменения).

Основные опции:
- `-a` (archive) — сохраняет права, владельца, временные метки и т.д. (рекурсивно, включает -rlptgoD)
- `-v` (verbose) — подробный вывод
- `-z` (compress) — сжатие при передаче
- `-h` (human-readable) — читаемый формат вывода
- `--delete` — удалять в целевой директории файлы, которых нет в источнике
- `--exclude` — исключить файлы/паттерны
- `-e` — указать удаленную shell-команду (например, -e ssh)

Примеры:
```bash
# Локальная синхронизация:
rsync -av /source/directory/ /destination/directory/    # Если в конце слеш - копируется содержимое

# Синхронизация с удаленным сервером через SSH:
rsync -avz -e ssh /local/path/ user@remote.server.com:/remote/path/

# Синхронизация с удаленного сервера на локальную машину:
rsync -avz -e ssh user@remote.server.com:/remote/path/ /local/path/

# Исключение файлов:
rsync -av --exclude='*.tmp' /source/ /destination/
```

<h3>8. Управление файлами и процессами с помощью xargs и lsof</h3>

Xargs позволяет строить и выполнять команды из стандартного ввода. Полезно, когда команда не принимает входные данные через stdin, а только как аргументы.

Примеры:
```bash
# Удаление файлов, найденных через find:
find . -name "*.log" -type f | xargs rm

# Если в именах файлов есть пробелы, используйте -0 (нулевой символ как разделитель) и в find опцию -print0:
find . -name "*.log" -type f -print0 | xargs -0 rm

# Выполнение команды для каждого элемента с подстановкой {} (с помощью -I):
cat urls.txt | xargs -I {} wget {}
```

Lsof выводит список открытых файлов и процессов, которые их используют. В Linux всё является файлом (включая сетевые соединения, устройства и т.д.).

Примеры:
```bash
# Показать все открытые файлы:
lsof

# Показать файлы, открытые конкретным процессом (по имени):
lsof -c nginx

# Показать файлы, открытые конкретным пользователем:
lsof -u username

# Показать сетевые соединения:
lsof -i

# Показать, какой процесс использует порт 80:
lsof -i :80
```

<h3>9. Настройка переменных окружения для скриптов</h3>

Переменные окружения используются для передачи настроек и параметров в скрипты и приложения.

Установка переменных:
```bash
# В текущей сессии:
export VARIABLE_NAME=value

# Для текущей сессии без экспорта (только для текущего shell):
VARIABLE_NAME=value
```

Просмотр переменных:
- Показать все переменные: `printenv` или `env`
- Показать значение конкретной переменной: `echo $VARIABLE_NAME`

Как сделать переменные постоянными:
- Для пользователя: добавить в `~/.bashrc` или `~/.profile`
- Для всех пользователей: добавить в `/etc/environment` или `/etc/profile`

Пример добавления в `~/.bashrc`:
```bash
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk
export PATH=$JAVA_HOME/bin:$PATH
```
После изменения `~/.bashrc` или `/etc/profile` нужно выполнить `source ~/.bashrc` или перезапустить терминал.

В bash-скриптах можно устанавливать переменные в начале, и они будут доступны в процессе выполнения скрипта. Чтобы скрипт использовал переменные окружения, установленные в текущей сессии, их не нужно экспортировать заново, если скрипт запущен в той же сессии.

Пример скрипта с использованием переменных окружения:
```bash
#!/bin/bash
echo "Пользователь: $USER"
echo "Домашний каталог: $HOME"
echo "Текущий каталог: $PWD"
```