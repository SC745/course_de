<h2>Руководство по Numpy</h2>
<h3>1. Введение</h3>

NumPy — это библиотека для научных вычислений в Python. Она предоставляет поддержку больших, многомерных массивов и матриц, включая коллекцию математических функций для работы с этими массивами.
Основные возможности NumPy:

- Многомерные массивы: Создание и манипуляция многомерными массивами (ndarray), которые могут быть использованы для хранения данных различных типов.
- Вычисления: Быстрые векторные арифметические операции, математические функции, линейная алгебра, статистика и многое другое.
- Индексация и срезы: Расширенные возможности для выборки подмножеств данных, транспонирования массивов и изменения их формы.
- Броадкастинг: Правила для выполнения арифметических операций между массивами разных размеров, расширяя их автоматически до совместимых форм. Это мощная особенность, которая делает код более читаемым и эффективным, избегая явного использования циклов. Принципы броадкастинга:
 - Если массивы имеют разное количество измерений, форма массива с меньшим количеством измерений дополняется единицами с ведущей (левой) стороны.
 - Если форма двух массивов не совпадает в каком-либо измерении, массив с размером, равным 1 в данном измерении, растягивается до соответствия форме другого массива.
 - В каждом измерении размеры должны либо совпадать, либо один из них должен быть равен 1.
 - Если в каком-либо измерении размеры не совпадают и ни один из них не равен 1, NumPy выдаст ошибку.

<h3>2. Операции с формой и структурой</h3>
<h4>Создание массивов</h4>

```python
# Из последовательностей
np.array([1, 2, 3, 4])                   # [1 2 3 4]
np.array([[1, 2], [3, 4]])               # 2D массив
np.arange(0, 10, 2)                      # Числа от 0 до 10 с шагом 2
np.linspace(0, 1, 5)                     # Равномерно распределенные 5 чисел от 0 до 1
np.logspace(0, 2, 5)                     # Логарифмическая шкала [1, 3.16, 10, 31.62, 100]

# Специальные массивы
np.zeros((3, 4))                         # Матрица 3x4 из нулей
np.ones((2, 3))                          # Матрица 2x3 из единиц
np.full((2, 2), 7)                       # Матрица 2x2 из семерок
np.eye(3)                                # Единичная матрица 3x3
np.empty((2, 2))                         # Неинициализированный массив
```

<h4>Изменение формы</h4>

```python
arr = np.arange(12)

arr.reshape(3, 4)          # Преобразовать в 3x4
np.reshape(arr, (3, 4))    # Аналогично
arr.flatten()              # Преобразовать в 1D (копия)
arr.ravel()                # Преобразовать в 1D (вид)
arr.copy()                # Копировать массив
```

<h4>Объединение и разделение</h4>

```python
a = np.array([1, 2])
b = np.array([3, 4])

np.concatenate([a, b])           # [1 2 3 4]
np.vstack([a, b])                # Вертикальное объединение
np.hstack([a, b])                # Горизонтальное объединение

arr = np.array([1, 2, 3, 4, 5, 6])
np.split(arr, 3)                 # Разделить на 3 части
```

<h4>Транспонирование</h4>

```python
arr2d = np.array([[1, 2, 3], [4, 5, 6]])
arr2d.T    # Транспонирование
```


<h3>3. Математические операции</h3>
<h4>Поэлементные операции</h4>

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

np.add(a, b)         # [5 7 9] - сложение (+)
np.subtract(a, b)    # [-3 -3 -3] - вычитание (-)
np.multiply(a, b)    # [4 10 18] - умножение (*)
np.divide(a, b)      # [0.25 0.4 0.5] - деление (/)
np.power(a, 2)       # [1 4 9] - возведение в степень (**)
np.sqrt(a)           # [1. 1.414 1.732] - квадратный корень
```

<h4>Тригонометрические операции</h4>

```python
angles = np.array([0, np.pi/2, np.pi])
np.sin(angles)        # [0. 1. 0.]
np.cos(angles)        # [1. 0. -1.]
np.tan(angles)        # [0. ∞ 0.]
```

<h4>Экспоненциальные и логарифмические операции</h4>

```python
np.exp([1, 2, 3])         # [2.718 7.389 20.085]
np.log([1, 10, 100])      # [0. 2.302 4.605] - натуральный логарифм
np.log10([1, 10, 100])    # [0. 1. 2.] - десятичный логарифм
```

<h4>Логические операции</h4>

```python
a = np.array([True, False, True])
b = np.array([False, True, True])

np.logical_and(a, b)  # [False False True] - логическое И (&)
np.logical_or(a, b)   # [True True True] - логическое ИЛИ (|)
np.logical_not(a)     # [False True False] - логическое НЕ (~)
np.logical_xor(a, b)  # [True True False] - исключающее ИЛИ
```

<h4>Операции линейной алгебры</h4>

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

np.dot(A, B)                # Матричное умножение
np.linalg.inv(A)            # Обратная матрица
np.linalg.det(A)            # Определитель
np.linalg.eig(A)            # Собственные значения и векторы
np.linalg.matrix_rank(A)    # Ранг матрицы
```

Для квадратной матрицы A размера n×n, ненулевой вектор v называется собственным вектором, а скаляр λ - собственным значением, если выполняется: `A · v = λ · v`

<h4>Условные операции</h4>

Фильтрация с помощью масок:
```python
arr = np.array([1, 2, 3, 4, 5, 6])
mask = arr > 3
filtered = arr[mask]             # [4 5 6]

# Множественные условия
mask2 = (arr > 2) & (arr < 5)    # AND
mask3 = (arr < 2) | (arr > 5)    # OR
mask4 = ~(arr > 3)               # NOT
```

Замена с помощью масок:
```python
arr = np.array([1, 2, 3, 4, 5])
result = np.where(arr > 3, arr, -1)
print(result)  # [-1 -1 -1  4  5]
```

Логические функции:
```python
# Проверка условий для всего массива
print(np.any(arr > 3))   # True (хотя бы один элемент > 3)
print(np.all(arr > 0))   # True (все элементы > 0)

# По осям для многомерных массивов
matrix = np.array([[1, 2], [3, 4]])
print(np.any(matrix > 2, axis=0))  # [False True]
print(np.all(matrix > 1, axis=1))  # [False True]
```

<h4>Агрегирование данных</h4>

Базовые агрегатные функции:
```python
arr = np.array([1, 2, 3, 4, 5])

np.sum(arr)        # 15
np.mean(arr)       # 3.0
np.std(arr)        # 1.414 (стандартное отклонение)
np.var(arr)        # 2.0 (дисперсия)
np.min(arr)        # 1
np.max(arr)        # 5
np.argmin(arr)     # 0 (индекс минимального)
np.argmax(arr)     # 4 (индекс максимального)

# Кумулятивные функции
np.cumsum(arr)     # [ 1  3  6 10 15] (кумулятивная сумма)
np.cumprod(arr)    # [ 1  2  6 24 120] (кумулятивное произведение)
```

Агрегация по осям:
```python
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(np.sum(matrix, axis=0))  # [12 15 18] (сумма по столбцам)
print(np.sum(matrix, axis=1))  # [ 6 15 24] (сумма по строкам)
print(np.sum(matrix))          # 45 (общая сумма)
```

Агрегация с условиями:
```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
np.sum(arr[arr > 5])                 # Сумма элементов, удовлетворяющих условию
np.sum(np.where(arr > 5, arr, 0))    # Или более эффективно
np.sum(arr % 2 == 0)                 # Количество элементов, удовлетворяющих условию
```

<h4>Группировка данных</h4>

С помощью np.unique():
```python
# Данные с категориями
categories = np.array(['A', 'B', 'A', 'C', 'B', 'A', 'C', 'C'])
values = np.array([10, 20, 15, 30, 25, 12, 35, 28])

# Находим уникальные категории
unique_cats, indices = np.unique(categories, return_inverse=True)

print(f"Уникальные категории: {unique_cats}")  # ['A' 'B' 'C']
print(f"Индексы категорий: {indices}")  # [0 1 0 2 1 0 2 2]

# Группируем значения по категориям
grouped_values = [values[indices == i] for i in range(len(unique_cats))]
```

С помощью np.bincount():
```python
# Для целочисленных категорий
int_categories = np.array([0, 1, 0, 2, 1, 0, 2, 2])
values = np.array([10, 20, 15, 30, 25, 12, 35, 28])

# Суммы по группам
sums = np.bincount(int_categories, weights=values)    # Суммы по группам: [37. 45. 93.]
counts = np.bincount(int_categories)                  # Количество элементов в группах [3 2 3]
means = sums / counts                                 # Среднее по группам [12.33333333 22.5 31.]
```

<h3>4. Специальные возможности</h3>
<h4>Производительность и оптимизация</h4>

Массивы numpy эффективны практически в 20 раз по сравнению со списками python при больщих размерах:
```python
import numpy as np
import random
import time

python_list = [random.randint(1, 1000) for i in range(10000000)]
numpy_array = np.array(python_list)

start_time = time.perf_counter()
max(python_list)
print(time.perf_counter() - start_time)    # 0.10607809999783058

start_time = time.perf_counter()
numpy_array.max()
print(time.perf_counter() - start_time)    # 0.005827599990880117
```

Для оптимизации памяти рекомендуется слудующее:
- Выбор правильного типа данных - int8 занимает в 4 раза меньше места, чем int32
- Упаковывание булевых массивов - вместо 1 байта 1 бит на элемент
- Использование операций, изменяющих новый массив вместо создания нового

<h4>Сохранение и загрузка данных</h4>

Созранение одного массива:
```python
data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
np.save('data.npy', data)            # Сохранение
loaded_data = np.load('data.npy')    # Загрузка
```

Созранение нескольких массивов:
```python
array1 = np.arange(10)
array2 = np.random.rand(5, 5)
array3 = np.ones((3, 3))

# Сохранение в .npz архив
np.savez('multiple_arrays.npz', arr1=array1, arr2=array2, arr3=array3)

# Загрузка
loaded_archive = np.load('multiple_arrays.npz')

# Доступ к отдельным массивам
loaded_array1 = loaded_archive['arr1']
loaded_array2 = loaded_archive['arr2']
```

Созранение в текстовый файл:
```python
# Создаем данные для сохранения
data = np.array([[1.0, 2.0, 3.0], 
                 [4.0, 5.0, 6.0], 
                 [7.0, 8.0, 9.0]])

# Сохранение в текстовый файл
np.savetxt('data.txt', data, delimiter=',', fmt='%.2f', header='x,y,z')

# Загрузка из текстового файла
loaded_data = np.loadtxt('data.txt', delimiter=',')
print("Загруженные данные:")
print(loaded_data)
```